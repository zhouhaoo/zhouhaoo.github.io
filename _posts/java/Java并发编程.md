---
layout:     post
title:      "Java并发编程"
subtitle:   "thread"
date:       2021-04-25
author:     "zhouhaoh"
tags:
    - JAVA
---



Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存。

线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

### 原子性，可见性和有序性。

1.  原子性：对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。使用原子数值类型（AtomBoolean等）
2.  可见性： 是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，所以对其他线程是可见的，当有其他线程需要读取时，它会去内存中读取新值。
   而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
3. 有序性：在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
   可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

###  volatile

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
- 禁止进行指令重排序。
- final也可以禁止重排序。

如何实现线程安全？

1. 不共享资源(不涉及到共享的资源)
2. 共享不可变资源 ``ThreadLocal``
3. 共享可变资源



### **ThreadLocal**

- 声明为全局的final成员
- 避免存储大量的对象
- 用完后及时移除对象



### ConcurrentHashMap

1. JDK5：分段锁（segment 16个），必要时加锁。
2. JDK6：优化二次Hash算法
3. JDK7：段懒加载，volatile cas
4. JDK8：基于hashMap原理并发实现 ，没有分段锁了。
